      program test

c     need to find way to keep ivarlen different for different cases

c     program 1) van der Pol (Hairer II, pp 403)
c     program 2) Pureshi and Russo 
c     program 3) Dekker 7.5.2 pp. 215 (Kaps problem   : Index 1)
c     program 4) Dekker 7.5.1 pp. 214 (Kreiss' problem: Index 2)

      parameter(is=9,ivarlen=4)
      parameter(isamp=71,jmax=81,jactual=81)

      parameter(rho=28.,sigma=10.,beta=8./3.)	!Case 5 paramters - Lorenz

      dimension aE(is,is),aI(is,is),bE(is),bI(is),cE(is),cI(is)
      dimension bEH(is),bIH(is),bD(is,4)
      dimension stageE(is),stageI(is),maxiter(is)
      dimension svpB(is,is,0:is),alpha(is,is)
      dimension al3N(is,is),al3D(is,is),bint(is)
      dimension al4N(is,is),al4D(is,is)

      dimension ustage(ivarlen,is),res(ivarlen,is)
      dimension predvec(ivarlen,is)

      dimension uvec(ivarlen),uveco(ivarlen),usum(ivarlen)
      dimension uveciter(ivarlen),uorig(ivarlen) 
      dimension uexact(ivarlen),Rnewton(ivarlen)
      dimension errvec(ivarlen),errvecT(ivarlen),tmpvec(ivarlen)
      dimension xjacinv(ivarlen,ivarlen)

      dimension cost(isamp),error1(isamp),error2(isamp),sig(isamp)
      dimension error1P(isamp),error2P(isamp)

      dimension epsave(jmax),b1save(jmax),b2save(jmax)
      dimension b1Psave(jmax),b2Psave(jmax)
      dimension epsilon(30)

      write(*,*)'what is ipred?'
      read(*,*)ipred

      do icase = 1,1                                     !   begin algorithms loop

        icount = 0        !  cost counters
        jcount = 0        !  cost counters

        do i = 1,nrk
          stageE(i) = 0.0
          stageI(i) = 0.0
          maxiter(i)= 0
        enddo
      
        call rungeadd(aE,aI,bE,bI,cE,cI,nrk,bEH,bIH,icase,bD,
     &   svpB(1,1,0),alpha,al3N,al3D,al4N,al4D,ipred)
 
        do iprob = 1,1                                 !   begin problems loop
      
c         loop over different values of stiffness epsilon 

          do jepsil = 1,jactual,1                              !  begin stiffness epsilon loop

            itmp = 11 - jmax/jactual
            ep = 1./10**((jepsil-1)/(itmp*1.))                           !  used for 81 values of ep

            write(50,*)'zone T = "ep = ',ep,'",'
            write(51,*)'zone T = "ep = ',ep,'",'
            write(52,*)'zone T = "ep = ',ep,'",'
            write(53,*)'zone T = "ep = ',ep,'",'

            do iDT = 1,isamp,1                                 !  timestep loop for vdP, Kaps, etc
c           do iDT = 1,1,1                                     ! use to determine the exact solution

            call INIT(uvec,uexact,dt,iDT,tfinal,ep,nvecLen,iprob)     !  initialize problem information

            dto = dt
            t = 0.

            do ival = 1,nvecLen
              errvecT(ival) = 0.0
            enddo

            do i = 1,nrk                                       !  initialize stage value preditor
              do ival = 1,nvecLen                              !  with trivial guess for first stage
                predvec(ival,i) = uvec(ival)
              enddo
            enddo


            do ktime = 1,100000000                      ! advance solution (time advancement loop )
      
              if(t+dt.gt.tfinal)dt = tfinal-t + 1.0e-11

              do ival = 1,nvecLen
                uveco(ival) = uvec(ival)
              enddo

              jcount = jcount + (nrk-1)                         !  keep track of total RK stages 

              do L = 1,nrk                                      !  begin RK loop

                ttI = t + cI(L)*dt
                
                call RHS(uvec,res(1,L),dt,ep,ttI,iprob)

                do ival = 1,nvecLen                             !  write the solution into a storage register
                  ustage(ival,L) = uvec(ival)
                enddo

              if(L.ne.nrk)then

                ttI = t + cI(L+1)*dt

                do ival = 1,nvecLen
                  usum(ival) = uveco(ival)
                enddo
                do LL = 1,L 
                  do ival = 1,nvecLen
                    usum(ival) = usum(ival) + aI(L+1,LL)*res(ival,LL)
                  enddo
                enddo

                do ival = 1,nvecLen
                  if(ipred.eq.2)predvec(ival,L+1)=uvec(ival)    ! previous guess as starter
                  uvec(ival)  = predvec(ival,L+1)               ! put predict into start guess
                  uorig(ival) = uvec(ival)                      ! put predict into storage for testing
                enddo

                if(L.gt.1.and.L.lt.nrk)then
                  do ival = 1,nvecLen
                    uvec(ival)  = uveco(ival)               ! put predict into start guess
                    do jpre = 2,L
                       Z = ustage(ival,jpre)-uveco(ival)
                       uvec(ival) = uvec(ival) + alpha(L+1,jpre)*Z
                       uorig(ival) = uvec(ival)               ! put predict into storage for testing
                    enddo
                  enddo
                endif

c U^{(n+1,4)} = al4_{1}*U^{(n  ,4)} + al4_{2}*U^{(n  ,5)} +
c             + al4_{3}*U^{(n  ,6)} + al4_{4}*U^{(n+1,2)} +
c             + al4_{5}*U^{(n+1,3)}


c al4_{i} = \sum_{j=1}^{2*(order)} al4N(i,j)*r^{j} /
c           \sum_{j=1}^{2*(order)} al4D(i,j)*r^{j}

                if(L.eq.2.and.ktime.ne.1)then
                  the1 = 1.
                  the2 = the1*the
                  the3 = the2*the
                  the4 = the3*the
                  the5 = the4*the
                  the6 = the5*the
                  the7 = the6*the
                  the8 = the7*the
                  do LL = 1,5
                    xnum = al3N(LL,1)*the1
     &                   + al3N(LL,2)*the2
     &                   + al3N(LL,3)*the3
     &                   + al3N(LL,4)*the4
     &                   + al3N(LL,5)*the5
     &                   + al3N(LL,6)*the6
     &                   + al3N(LL,7)*the7
     &                   + al3N(LL,8)*the8
                    xden = al3D(LL,1)*the1
     &                   + al3D(LL,2)*the2
     &                   + al3D(LL,3)*the3
     &                   + al3D(LL,4)*the4
     &                   + al3D(LL,5)*the5
     &                   + al3D(LL,6)*the6
     &                   + al3D(LL,7)*the7
     &                   + al3D(LL,8)*the8
                    bint(LL) = xnum/xden
                  enddo
                    bint(1) =  9.9518675264213746 
                    bint(2) =  4.8366852488953721 
                    bint(3) =-24.163405114569394 
                    bint(4) = 14.152132944153401
                    bint(5) =  0.94399768676237158
                  do ival = 1,nvecLen
                    Z1 = ustage(ival,3)-ustage(ival,3)
                    Z2 = ustage(ival,4)-ustage(ival,3)
                    Z3 = ustage(ival,5)-ustage(ival,3)
                    Z4 = ustage(ival,6)-ustage(ival,3)
                    Z5 = ustage(ival,2)-ustage(ival,3)
                    uvec(ival) = ustage(ival,3) + bint(1)*z1
     &                                          + bint(2)*z2
     &                                          + bint(3)*z3
     &                                          + bint(4)*z4
     &                                          + bint(5)*z5
                    uorig(ival) = uvec(ival)               ! put predict into storage for testing
                  enddo

c                 do ival = 1,nvecLen
c                   uvec(ival) = bint(1)*ustage(ival,3)
c    &                         + bint(2)*ustage(ival,4)
c    &                         + bint(3)*ustage(ival,5)
c    &                         + bint(4)*ustage(ival,6)
c    &                         + bint(5)*ustage(ival,2)
c                   uvec(ival) = bint(1)*ustage(ival,4)
c    &                         + bint(2)*ustage(ival,5)
c    &                         + bint(3)*ustage(ival,6)
c    &                         + bint(4)*ustage(ival,2)
c    &                         + bint(5)*ustage(ival,3)
c                   uorig(ival) = uvec(ival)               ! put predict into storage for testing
c                 enddo
                endif

                do k = 1,20

                  icount = icount + 1

                  do ival = 1,nvecLen
                    uveciter(ival) = uvec(ival)
                  enddo

                  call RHS(uvec,res(1,L+1),dt,ep,ttI,iprob)

                  do ival = 1,nvecLen
                    Rnewton(ival) =  
     &              uvec(ival)  - aI(L+1,L+1)*res(ival,L+1) - usum(ival)
                  enddo

            call JACOB(uvec,xjacinv,dt,ep,aI(L+1,L+1),ttI,iprob,nvecLen)

                  do i = 1,nvecLen
                    do j = 1,nvecLen
                      uvec(i) = uvec(i) - xjacinv(i,j)*Rnewton(j)
                    enddo
                  enddo

                  tmp = 0.0
                  do ival = 1,nvecLen
                     tmp = tmp + abs(uvec(ival)-uveciter(ival))
                  enddo
                  if(tmp.lt.1.e-12) go to 160                 !  kick out of newton iteration

                enddo
  160           continue
 
             if((k.gt.maxiter(L+1)).and.(ktime.ne.1))maxiter(L+1)=k

              do ival = 1,nvecLen                    !  write the solution into a storage register
                ustage(ival,L+1) = uvec(ival)
              enddo

              xnorm = 0.0                                     !  assess how good initial guess was
              snorm = 0.0                                     !  assess how good initial guess was
              do ival = 1,nvecLen
                tmpD = (uvec(ival) - uorig(ival))
                xnorm = xnorm + tmpD*tmpD
                snorm = snorm + uvec(ival)*uvec(ival)
              enddo                                         
              xnorm = sqrt(xnorm/snorm)
              stageE(L+1) = stageE(L+1) + xnorm
              stageI(L+1) = stageI(L+1) + 1.*k

              elseif(L.eq.nrk) then
            
                do ival = 1,nvecLen
                  uvec(ival) = uveco(ival)
                enddo

                do ival = 1,nvecLen
                  do LL = 1,nrk 
                    uvec(ival) = uvec(ival) + bI(LL)*res(ival,LL)
                  enddo
                enddo

                if(time.lt.tfinal-1.0e-11)then               !  begin predicted error

                do ival = 1,nvecLen
                  errvec(ival) = 0.0
                  do LL = 1,nrk 
                    errvec(ival) = errvec(ival) 
     &                       + dt*( (bI(LL)-bIH(LL))*res(ival,LL) )
                  enddo
                  errvec(ival) = abs(errvec(ival))
                enddo
                rat = 1.0

                endif                                        !  end predicted error

c              predict new values stage values :  about 100 different kinds

c                                           !  note that ipred=2 is accomplished elsewhere
                
               if(ipred.eq.1)then
c              begin with dense output
                do K=2,nrk
                  do ival = 1,nvecLen
                    predvec(ival,K) = uvec(ival)
                  enddo
                enddo

                elseif(ipred.eq.3)then

                do K=2,nrk
                  do ival = 1,nvecLen
                    predvec(ival,K) = uveco(ival)
                    the = (1.+cI(K)*rat)
                    do LL = 1,nrk
                      bb = bD(LL,1)*the
     &                   + bD(LL,2)*the*the
     &                   + bD(LL,3)*the*the*the
     &                   + bD(LL,4)*the*the*the*the
                    predvec(ival,K) = predvec(ival,K) + bb*res(ival,LL)
                    enddo
                  enddo
                enddo

                elseif(ipred.eq.4.or.ipred.eq.5)then

c              stage value predictors
c  U^(n+1,i+1) =                  \sum_{k=0}^{order} (etah_{i k}*r^(k)) * U^{n-1} +
c                \sum_{j=1}^{s-1} \sum_{k=0}^{order} ( BBh_{ijk}*r^(k)) * U^{n,j+1}

                do ival = 1,nvecLen
                  do inew=2,nrk
                    predvec(ival,inew) = 0.0
                    do j = 1,nrk
                      the = 1.
                      bb = svpB(inew,j,0)
     &                   + svpB(inew,j,1)*the
     &                   + svpB(inew,j,2)*the*the
     &                   + svpB(inew,j,3)*the*the*the
     &                   + svpB(inew,j,4)*the*the*the*the
                      predvec(ival,inew) = predvec(ival,inew) 
     &                                   + bb*ustage(ival,j)
                    enddo
                  enddo
                enddo

                endif


              endif

            enddo                                            ! end RK loop

            do ival = 1,nvecLen
              errvecT(ival) = errvecT(ival) + errvec(ival)
            enddo                                         

            t = t + dt

            if(t.ge.tfinal) go to 100

          enddo                                              ! end time advancement loop

  100  continue
       
          cost(iDT) = alog10((nrk-1)/dto)                    !  nrk - 1 implicit stages

          totalerror  = 0.0
          totalerrorP = 0.0
          do ival = 1,nvecLen
            tmpvec(ival) = abs(uvec(ival)-uexact(ival))
            if(tmpvec(ival).eq.0.0)tmpvec(ival)=1.0e-15
            totalerror  = totalerror  + tmpvec(ival)**2 
            totalerrorP = totalerrorP + errvecT(ival)**2 
          enddo
          totalerror = sqrt(totalerror/nvecLen)

          error1(iDT)  = alog10(tmpvec(1))
          error2(iDT)  = alog10(tmpvec(2))
          error1P(iDT) = alog10(errvecT(1))
          error2P(iDT) = alog10(errvecT(2))
  
          write(50,50)cost(iDT),error1(iDT)
          write(51,50)cost(iDT),error2(iDT)
          write(52,50)cost(iDT),error1P(iDT)
          write(53,50)cost(iDT),error2P(iDT)


         enddo                                             !  end  loop over different dt

           jsamp = 41 

c          if(icase.eq.1)then                        !  make sure that data has not hit machine precision
c            jsamp = 51      
c          elseif(icase.eq.2)then
c            jsamp = 51      
c          elseif(icase.eq.3)then
c            jsamp = 51      
c          elseif(icase.eq.4)then
c            jsamp = 51      
c          endif
  
           do i=1,isamp
             sig(i) = 0.0
           enddo
 
           call fit(cost,error1,jsamp,sig,0,a1,b1,siga1,sigb1,chi2,q)
           call fit(cost,error2,jsamp,sig,0,a2,b2,siga2,sigb2,chi2,q)
           call fit(cost,error1P,jsamp,sig,0,a3,b3,siga3,sigb3,chi2,q)
           call fit(cost,error2P,jsamp,sig,0,a4,b4,siga3,sigb3,chi2,q)
           write(*,60)ep,a1,b1,a2,b2,a3,b3,a4,b4

           epsave(jepsil) = log10(ep)
           b1save(jepsil) = -b1
           b2save(jepsil) = -b2
           b1Psave(jepsil) = -b3
           b2Psave(jepsil) = -b4

         enddo                                              !  end stiffness epsilon loop

         write(35,*)'zone T = "Diff Var: Implicit",'
         do j=1,jactual
           write(35,50)epsave(j),b1save(j)
         enddo
         write(35,*)'zone T = "Alge Var: Implicit",'
         do j=1,jactual
           write(35,50)epsave(j),b2save(j)
         enddo
         write(35,*)'zone T = "Diff Var: Predicted",'
         do j=1,jactual
           write(35,50)epsave(j),b1Psave(j)
         enddo
         write(35,*)'zone T = "Alge Var: Predicted",'
         do j=1,jactual
           write(35,50)epsave(j),b2Psave(j)
         enddo

        enddo                                            !  end problems loop

       enddo                                             !  end algorithms loop

   60  format( e12.5,1x,12(f8.3,1x))

   50  format( 10(e12.5,1x))

       tmp = 1.0*icount/jcount
       write(*,*)'average iterations per step',tmp

       do istage = 2,nrk
         stageE(istage) = (nrk-1)*stageE(istage)/jcount
         stageI(istage) = (nrk-1)*stageI(istage)/jcount
       enddo
       write(*,*)'error of initial guess is '
       do istage = 2,nrk
         write(*,*) istage,stageE(istage),maxiter(istage),stageI(istage)
       enddo

       stop
       end

      subroutine INIT(uvec,uexact,dt,iDT,tfinal,ep,nvecLen,iprob)
      parameter(is=9,ivarlen=4)
        dimension uvec(ivarlen),uexact(ivarlen)
        dimension ExactTot(81,3)

        if(iprob.eq.1)then                 !  van der Pol (Hairer II, pp 403)
c    vanderPol has 8 decades with 10 levels of epsilon per decade plus 1st pt of 9th decade
 
         open(unit=39,file='exact.vanderpol.data')

          rewind(39)
          do i=1,81
            read(39,*)ExactTot(i,1),ExactTot(i,2)
            ExactTot(i,3) = 1./10**((i-1)/(10.))                  !  used for 81 values of ep
          enddo

          do i=1,81
            diff = abs(ExactTot(i,3) - ep)
            if(diff.le.1.0e-10)then
              uexact(1) = ExactTot(i,1)
              uexact(2) = ExactTot(i,2)
              go to 1 
            endif
          enddo
   1      continue

          dt = 0.5/10**((iDT-1.)/20.)
          nvecLen = 2
          tfinal = 0.5

          uvec(1) = 2.
          uvec(2) = -0.6666654321121172

        elseif(iprob.eq.2)then                     !  Pureshi and Russo 
 
          open(unit=39,file='exact.pureschi.1.data')
c         open(unit=39,file='exact.pureschi.2.data')


          rewind(39)
          do i=1,81
            read(39,*)ExactTot(i,1),ExactTot(i,2)
            ExactTot(i,3) = 1./10**((i-1)/(10.))                  !  used for 81 values of ep
          enddo

          do i=1,81
            diff = abs(ExactTot(i,3) - ep)
            if(diff.le.1.0e-10)then
              uexact(1) = ExactTot(i,1)
              uexact(2) = ExactTot(i,2)
              go to 2
            endif
          enddo
   2      continue

          dt = 0.5/10**((iDT-1.)/20.)
          nvecLen = 2
          tfinal = 5.0

          pi = acos(-1.)

c  IC: problem 1   :  equilibrium IC
          uvec(1) = pi/2.
          uvec(2) = sin(pi/2.)
c  IC: problem 2   :  non-equilibrium IC
c         uvec(1) = pi/2.
c         uvec(2) = 1./2.

        elseif(iprob.eq.3)then                   ! Dekker 7.5.2 pp. 215 (Kaps problem   : Index 1)
 
          dt = 0.5/10**((iDT-1.)/20.)
          nvecLen = 2

          tfinal = 1.0
          tmp = exp(-tfinal)
          uexact(1) = tmp*tmp
          uexact(2) = tmp

c  IC: problem 1   :  equilibrium IC
          uvec(1) = 1.
          uvec(2) = 1.
c  IC: problem 2   :  non-equilibrium IC
c         uvec(1) = ?
c         uvec(2) = ?

        elseif(iprob.eq.4)then          ! Dekker 7.5.1 pp. 214 (Kreiss' problem: Index 2)
 
          dt = 0.5/10**((iDT-1.)/20.)
          nvecLen = 2

          tfinal = 1.0
          tmpP = exp(+tfinal   )
          tmpM = exp(-tfinal/ep)
          tmp = exp(tfinal)
          uo = 1.
          vo = 1.
          uexact(1) = uo*tmpP + vo*(tmpP - tmpM)/(1. + ep)
          uexact(2) = vo*tmpM

c  IC: problem 1   :  equilibrium IC
          uvec(1) = uo
          uvec(2) = vo
c  IC: problem 2   :  non-equilibrium IC
c         uvec(1) = ?
c         uvec(2) = ?
	elseif(iprob.eq.5)then
	
	  dt = 0.5/10**((iDT-1.)/20.)
	  nveclen = 2 !!!!!!!!!!! has something to do with jacobians, but not sure if it is relevant

	  tfinal = 1.0 !!arbitrary
	

        endif

      return
      end





      

     

      FUNCTION gammq(a,x)
      REAL a,gammq,x
c     USES gcf,gser
c     Returns the incomplete gamma function Q(a, x) = 1 -P(a, x).
      REAL gammcf ,gamser ,gln
      if(x.lt.0. .or.a.le.0.)pause 'bad arguments in gammq'
      if (x .lt .a+1. ) then 
      call gser(gamser,a,x,gln)
      gammq=1. -gamser 
      call gcf(gammcf,a,x,gln)
      endif
      return
      end

      FUNCTION gammln(xx)
      REAL gammln,xx
      INTEGER j
      DOUBLE PRECISION ser,stp,tmp,x,y,cof(6)
      SAVE cof,stp
      DATA cof,stp/76.18009172947146d0,-86.50532032941677d0,
     &24.01409824083091d0,-1.231739572450155d0,.1208650973866179d-2,
     &-.5395239384953d-5,2.5066282746310005d0/
      x=xx
      y=x
      tmp=x+5.5d0
      tmp=(x+0.5d0)*log(tmp)-tmp
      ser=1.000000000190015d0
      do j=1,6
      y=y+1.d0
      ser=ser+cof(j)/y
      enddo 
      gammln=tmp+log(stp*ser/x)
      return
      end

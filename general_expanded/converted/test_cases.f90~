      program test_cases

      implicit none 
!     program 1) van der Pol (Hairer II, pp 403)
!     program 2) Pureshi and Russo 
!     program 3) Dekker 7.5.2 pp. 215 (Kaps problem   : Index 1)
!     program 4) Dekker 7.5.1 pp. 214 (Kreiss' problem: Index 2)
!     WARNING: Kreiss has problem with algebraic variable
!     program 5) Lorenz
      
      integer, parameter :: wp=8

      integer, parameter  :: is=9,ivarlen=4
      integer, parameter  :: isamp=71,jmax=81,jactual=81
      
      integer             :: ipred
      integer             :: cases 			!input range of runge kutta cases
      integer             :: problem			!input problem number
      real(wp)            :: dt,itmp,ep,t,sigma,rho,beta,tfinal
      integer             :: icase,icount,jcount,i,iprob,nrk,jepsil
      integer             :: ii,iDT,nveclen,ival,ktime,L,LL
      integer             :: jpre,inew,j,k,jsamp,istage
      real(wp)            :: ttI,Z,time,rat,bb,xnum,xden,z1,z2,z3,z4,z5
      real(wp)            :: the,the1,the2,the3,the4,the5,the6,the7,the8
      real(wp)            :: tmp,xnorm,snorm,tmpD,dto,totalerror,totalerrorp

      real(wp), dimension(is,is) :: aE,aI,alpha,al3N,al3D,al4N,al4D
      real(wp), dimension(is) :: bE,bI,cE,cI,bEH,bIH,stageE,stageI
      real(wp), dimension(is) :: maxiter,bint
      real(wp), dimension(is,ivarlen) :: bD
      real(wp), dimension(is,is,0:is) :: svpB
      real(wp), dimension(ivarlen,is) :: ustage,res,predvec
      real(wp), dimension(ivarlen) :: uvec,uveco,usum,uveciter,uorig
      real(wp), dimension(ivarlen) :: uexact,Rnewton,errvec,errvecT,tmpvec
      real(wp), dimension(ivarlen,ivarlen) :: xjacinv
      real(wp), dimension(isamp) :: cost,sig
      real(wp), dimension(isamp,ivarlen) :: error1,error1P
      real(wp), dimension(ivarlen*2) :: a,b,siga1,sigb1,chi2
      real(wp), dimension(jmax,ivarlen) :: b1save,b1Psave
      real(wp), dimension(jmax) :: epsave


      write(*,*)'what is ipred?'
      read(*,*)ipred
      write(*,*)'what is case?'
      read(*,*)cases
      write(*,*)'which problem?'
      read(*,*)problem

      do icase = cases,cases                                  !   begin algorithms loop

        icount = 0        !  cost counters
        jcount = 0        !  cost counters
   
        call rungeadd(aE,aI,bE,bI,cE,cI,nrk,bEH,bIH,icase,bD, & !icase is the only input
     &   svpB(1,1,0),alpha,al3N,al3D,al4N,al4D)


        do i = 1,nrk
          stageE(i) = 0.0
          stageI(i) = 0.0
          maxiter(i)= 0
        enddo



        do iprob = problem,problem                                !   begin problems loop

!         loop over different values of stiffness epsilon 

          do jepsil = 1,jactual,1                              !  begin stiffness epsilon loop

            itmp = 11 - jmax/jactual
            ep = 1./10**((jepsil-1)/(itmp*1.))                           !  used for 81 values of ep
            
            do ii = 1,ivarlen
              write(49+ii,*)'zone T = "ep = ',ep,'",'
              write(59+ii,*)'zone T = "ep = ',ep,'",'
            enddo

            do iDT = 1,isamp,1                                 !  timestep loop for vdP, Kaps, etc
!            do iDT = 1,1,1                                     ! use to determine the exact solution

            call INIT(uvec,uexact,dt,iDT,tfinal,ep,nvecLen,iprob,sigma,rho,beta)     !  initialize problem information
            dto = dt
            t = 0.

            do ival = 1,nvecLen
              errvecT(ival) = 0.0
            enddo

            do i = 1,nrk                                       !  initialize stage value preditor
              do ival = 1,nvecLen                              !  with trivial guess for first stage
                predvec(ival,i) = uvec(ival)
              enddo
            enddo


            do ktime = 1,100000000                      ! advance solution (time advancement loop )

              if(t+dt.gt.tfinal)dt = tfinal-t + 1.0e-11

              do ival = 1,nvecLen
                uveco(ival) = uvec(ival)
              enddo

              jcount = jcount + (nrk-1)                         !  keep track of total RK stages 

              do L = 1,nrk                                      !  begin RK loop

                ttI = t + cI(L)*dt
                
                call RHS(uvec,res(1,L),dt,ep,iprob,sigma,rho,beta)

                do ival = 1,nvecLen                             !  write the solution into a storage register
                  ustage(ival,L) = uvec(ival)
                enddo

              if(L.ne.nrk)then

                ttI = t + cI(L+1)*dt

                do ival = 1,nvecLen
                  usum(ival) = uveco(ival)
                enddo
                do LL = 1,L 
                  do ival = 1,nvecLen
                    usum(ival) = usum(ival) + aI(L+1,LL)*res(ival,LL)
                  enddo
                enddo

                do ival = 1,nvecLen
                  if(ipred.eq.2)predvec(ival,L+1)=uvec(ival)    ! previous guess as starter
                  uvec(ival)  = predvec(ival,L+1)               ! put predict into start guess
                  uorig(ival) = uvec(ival)                      ! put predict into storage for testing
                enddo

                if(L.gt.1.and.L.lt.nrk)then
                  do ival = 1,nvecLen
                    uvec(ival)  = uveco(ival)               ! put predict into start guess
                    do jpre = 2,L
                       Z = ustage(ival,jpre)-uveco(ival)
                       uvec(ival) = uvec(ival) + alpha(L+1,jpre)*Z
                       uorig(ival) = uvec(ival)               ! put predict into storage for testing
                    enddo
                  enddo
                endif

! U^{(n+1,4)} = al4_{1}*U^{(n  ,4)} + al4_{2}*U^{(n  ,5)} +
!             + al4_{3}*U^{(n  ,6)} + al4_{4}*U^{(n+1,2)} +
!             + al4_{5}*U^{(n+1,3)}


! al4_{i} = \sum_{j=1}^{2*(order)} al4N(i,j)*r^{j} /
!           \sum_{j=1}^{2*(order)} al4D(i,j)*r^{j}

                if(L.eq.2.and.ktime.ne.1)then
                  the1 = 1.
                  the2 = the1*the
                  the3 = the2*the
                  the4 = the3*the
                  the5 = the4*the
                  the6 = the5*the
                  the7 = the6*the
                  the8 = the7*the
                  do LL = 1,5
                    xnum = al3N(LL,1)*the1&
     &                   + al3N(LL,2)*the2&
     &                   + al3N(LL,3)*the3&
     &                   + al3N(LL,4)*the4&
     &                   + al3N(LL,5)*the5&
     &                   + al3N(LL,6)*the6&
     &                   + al3N(LL,7)*the7&
     &                   + al3N(LL,8)*the8
                    xden = al3D(LL,1)*the1&
     &                   + al3D(LL,2)*the2&
     &                   + al3D(LL,3)*the3&
     &                   + al3D(LL,4)*the4&
     &                   + al3D(LL,5)*the5&
     &                   + al3D(LL,6)*the6&
     &                   + al3D(LL,7)*the7&
     &                   + al3D(LL,8)*the8
                    bint(LL) = xnum/xden
                  enddo
                    bint(1) =  9.9518675264213746 
                    bint(2) =  4.8366852488953721 
                    bint(3) =-24.163405114569394 
                    bint(4) = 14.152132944153401
                    bint(5) =  0.94399768676237158
                  do ival = 1,nvecLen
                    Z1 = ustage(ival,3)-ustage(ival,3)
                    Z2 = ustage(ival,4)-ustage(ival,3)
                    Z3 = ustage(ival,5)-ustage(ival,3)
                    Z4 = ustage(ival,6)-ustage(ival,3)
                    Z5 = ustage(ival,2)-ustage(ival,3)
                    uvec(ival) = ustage(ival,3) + bint(1)*z1&
     &                                          + bint(2)*z2&
     &                                          + bint(3)*z3&
     &                                          + bint(4)*z4&
     &                                          + bint(5)*z5
                    uorig(ival) = uvec(ival)               ! put predict into storage for testing
                  enddo

!                 do ival = 1,nvecLen
!                   uvec(ival) = bint(1)*ustage(ival,3)
!    &                         + bint(2)*ustage(ival,4)
!    &                         + bint(3)*ustage(ival,5)
!    &                         + bint(4)*ustage(ival,6)
!    &                         + bint(5)*ustage(ival,2)
!                   uvec(ival) = bint(1)*ustage(ival,4)
!    &                         + bint(2)*ustage(ival,5)
!    &                         + bint(3)*ustage(ival,6)
!    &                         + bint(4)*ustage(ival,2)
!    &                         + bint(5)*ustage(ival,3)
!                   uorig(ival) = uvec(ival)               ! put predict into storage for testing
!                 enddo
                endif

                do k = 1,20

                  icount = icount + 1

                  do ival = 1,nvecLen
                    uveciter(ival) = uvec(ival)
                  enddo

                  call RHS(uvec,res(1,L+1),dt,ep,iprob,sigma,rho,beta)

                  do ival = 1,nvecLen
                    Rnewton(ival) =&  
     &              uvec(ival)  - aI(L+1,L+1)*res(ival,L+1) - usum(ival)
                  enddo

            call JACOB(uvec,xjacinv,dt,ep,aI(L+1,L+1),iprob,nvecLen)

                  do i = 1,nvecLen
                    do j = 1,nvecLen
                      uvec(i) = uvec(i) - xjacinv(i,j)*Rnewton(j)
                    enddo
                  enddo

                  tmp = 0.0
                  do ival = 1,nvecLen
                     tmp = tmp + abs(uvec(ival)-uveciter(ival))
                  enddo
                  if(tmp.lt.1.e-12) go to 160                 !  kick out of newton iteration

                enddo
  160           continue
 
             if((k.gt.maxiter(L+1)).and.(ktime.ne.1))maxiter(L+1)=k

              do ival = 1,nvecLen                    !  write the solution into a storage register
                ustage(ival,L+1) = uvec(ival)
              enddo

              xnorm = 0.0                                     !  assess how good initial guess was
              snorm = 0.0                                     !  assess how good initial guess was
              do ival = 1,nvecLen
                tmpD = (uvec(ival) - uorig(ival))
                xnorm = xnorm + tmpD*tmpD
                snorm = snorm + uvec(ival)*uvec(ival)
              enddo                                         
              xnorm = sqrt(xnorm/snorm)
              stageE(L+1) = stageE(L+1) + xnorm
              stageI(L+1) = stageI(L+1) + 1.*k

              elseif(L.eq.nrk) then
            
                do ival = 1,nvecLen
                  uvec(ival) = uveco(ival)
                enddo

                do ival = 1,nvecLen
                  do LL = 1,nrk 
                    uvec(ival) = uvec(ival) + bI(LL)*res(ival,LL)
                  enddo
                enddo

                if(time.lt.tfinal-1.0e-11)then               !  begin predicted error

                do ival = 1,nvecLen
                  errvec(ival) = 0.0
                  do LL = 1,nrk 
                    errvec(ival) = errvec(ival)& 
     &                       + dt*( (bI(LL)-bIH(LL))*res(ival,LL) )
                  enddo
                  errvec(ival) = abs(errvec(ival))
                enddo
                rat = 1.0

                endif                                        !  end predicted error

!              predict new values stage values :  about 100 different kinds

!                                           !  note that ipred=2 is accomplished elsewhere
                
               if(ipred.eq.1)then
!              begin with dense output
                do K=2,nrk
                  do ival = 1,nvecLen
                    predvec(ival,K) = uvec(ival)
                  enddo
                enddo

                elseif(ipred.eq.3)then

                do K=2,nrk
                  do ival = 1,nvecLen
                    predvec(ival,K) = uveco(ival)
                    the = (1.+cI(K)*rat)
                    do LL = 1,nrk
                      bb = bD(LL,1)*the&
     &                   + bD(LL,2)*the*the&
     &                   + bD(LL,3)*the*the*the&
     &                   + bD(LL,4)*the*the*the*the
                    predvec(ival,K) = predvec(ival,K) + bb*res(ival,LL)
                    enddo
                  enddo
                enddo

                elseif(ipred.eq.4.or.ipred.eq.5)then

!              stage value predictors
!  U^(n+1,i+1) =                  \sum_{k=0}^{order} (etah_{i k}*r^(k)) * U^{n-1} +
!                \sum_{j=1}^{s-1} \sum_{k=0}^{order} ( BBh_{ijk}*r^(k)) * U^{n,j+1}

                do ival = 1,nvecLen
                  do inew=2,nrk
                    predvec(ival,inew) = 0.0
                    do j = 1,nrk
                      the = 1.
                      bb = svpB(inew,j,0)&
                        + svpB(inew,j,1)*the&
                        + svpB(inew,j,2)*the*the&
                        + svpB(inew,j,3)*the*the*the&
                        + svpB(inew,j,4)*the*the*the*the
                      predvec(ival,inew) = predvec(ival,inew)& 
     &                                   + bb*ustage(ival,j)
                    enddo
                  enddo
                enddo

                endif


              endif

            enddo                                            ! end RK loop

            do ival = 1,nvecLen
              errvecT(ival) = errvecT(ival) + errvec(ival)
            enddo                                         

            t = t + dt

            if(t.ge.tfinal) go to 100

          enddo                                              ! end time advancement loop

  100  continue
       
          cost(iDT) = log10((nrk-1)/dto)                    !  nrk - 1 implicit stages

          totalerror  = 0.0
          totalerrorP = 0.0
          do ival = 1,nvecLen
            tmpvec(ival) = abs(uvec(ival)-uexact(ival))
            if(tmpvec(ival).eq.0.0)tmpvec(ival)=1.0e-15
            totalerror  = totalerror  + tmpvec(ival)**2 
            totalerrorP = totalerrorP + errvecT(ival)**2 
          enddo
          totalerror = sqrt(totalerror/nvecLen)

          do ii = 1,nveclen
            error1(iDT,ii)  = log10(tmpvec(ii))
            error1P(iDT,ii) = log10(errvecT(ii))
            write(49+ii,*)cost(iDT),error1(iDT,ii)
            write(59+ii,*)cost(iDT),error1P(iDT,ii)
          enddo
  
         enddo                                             !  end  loop over different dt

           jsamp = 41 

!          if(icase.eq.1)then                        !  make sure that data has not hit machine precision
!            jsamp = 51      
!          elseif(icase.eq.2)then
!            jsamp = 51      
!          elseif(icase.eq.3)then
!            jsamp = 51      
!          elseif(icase.eq.4)then
!            jsamp = 51      
!          endif
  
           do i=1,isamp
             sig(i) = 0.0
           enddo

!-- gather values for output
	   do ii = 1,nveclen
             call fit(cost,error1(:,ii),jsamp,sig,0,a(ii),&
     & b(ii),siga1(ii),sigb1(ii),chi2(ii),q)
             call fit(cost,error1P(:,ii),jsamp,sig,0,a(ii+nveclen),&
     & b(ii+nveclen),siga1(ii+nveclen),sigb1(ii+nveclen),&
     & chi2(ii+nveclen),q)
	   enddo
           
!--output to terminal
           write(*,60,advance="no")ep
           do ii = 1,nveclen*2-1
             write(*,60,advance="no")a(ii),b(ii)
           enddo
           write(*,60)a(nveclen*2),b(nveclen*2)

           epsave(jepsil) = log10(ep)
           do ii = 1,nveclen
            b1save(jepsil,ii) = -b(ii)
            b1Psave(jepsil,ii) = -b(ii+nveclen)
           enddo
	! test outputs
           !print *,'x:',uvec(1)
           !print *,'y:',uvec(2)
           !print *,'z:',uvec(3)
           !write(33,*)uvec(1),uvec(2),uvec(3)
         enddo                                              !  end stiffness epsilon loop

!--write to fort.35
         do ii=1,nveclen
           write(35,*)'zone T = "Var ',ii,': Implicit",'
           do j=1,jactual
             write(35,50)epsave(j),b1save(j,ii)
           enddo
           write(35,*)'zone T = "Var ',ii,': Predicted",'
           do j=1,jactual
             write(35,50)epsave(j),b1Psave(j,ii)
           enddo
         enddo

        enddo                                            !  end problems loop

       enddo                                             !  end algorithms loop

   60  format( e12.5,1x,12(f8.3,1x))

   50  format( 10(e12.5,1x))

       tmp = 1.0*icount/jcount
       write(*,*)'average iterations per step',tmp

       do istage = 2,nrk
         stageE(istage) = (nrk-1)*stageE(istage)/jcount
         stageI(istage) = (nrk-1)*stageI(istage)/jcount
       enddo
       write(*,*)'error of initial guess is '
       do istage = 2,nrk
         write(*,*) istage,stageE(istage),maxiter(istage),stageI(istage)
       enddo
       stop
       end

   
